# Js + ES6

### JavaScript 面向对象的理解和感悟

- 什么是面向对象，面向对象有哪些特点，以及这些特点的解释(基础点)
  - 面向对象是基于面向过程而言，是把一个个问题抽象成对象的形式，把解决问题的方法作为这个对象的属性或方法
  
  - 面向对象具有封装、继承、多态的特性
    - 封装： 其主要目的是为数据提供有效性准确性和安全性，以及更好的代码复用，从设计层面在代码级别上对实现层面的管理和控制，降低开发风险或成本；像访问修饰符(public private 默认 protected等)、对象的get (读)或set(修改)方法、以及使用的一些api或平时使用的框架都是对封装的一种实践
    
    - 继承：是指某个对象能获得另一个对象的属性和方法，继承可以实现使用现有的类方法属性而不需要额外的编码；实现继承一般通过inheritance和composition两种方式，从继承概念上来说又可以有接口继承和实现继承，实现继承完全复用父类的属性方法，接口继承则是复用属性和方法的名称，其具体的实现方式还需子类内部自己实现。在es中，其实一开始是没有类的概念，就算新的es6中的类也是es5构造+原型继承上的一种语法糖，而且es中没有函数签名的概念，所以在继承实现方面，不能用接口实现继承，只能支持实现继承。
    
      - **构造函数模式**： 为创建对象es提出了构造函数模式，但是这种方法存在的一个问题是每次实例化对象的时候都会新建一个新的方法，函数也是一个对象，这样就导致不同实例上的同名函数其实不相等；
    
      - **原型链继承**： 所以基于此引入了原型链继承的概念，通过设置构造函数的prototype，所有实例内部_proto_指向原型对象，原型继承最大的问题是如果原型上是一个引用对象，当一个实例更改这个引用对象后，所有实例的这个值都会被修改，不能向超类型中的构造函数传递参数；
    
      - **借用构造函数**：在子类型的构造函数内调用超类的构造函数方法(**SuperType.call(this)**),可以想超类传参，但是也有构造函数带来的问题，以及超类的原型上的属性和方法不能获取
    
      - **组合继承**： 基于此，又提出了组和继承(原型链+借用构造函数)，通过构造函数定义实例的属性，而原型上定义实例共享的属性和方法，这种方式应该是目前es中应用最广泛的一中模式；组合继承其实也存在一种问题，就是当子类要重写父类一些属性时，父类的构造函数会调用两次，一次是在给子类原型赋值，另一个就是在子类构造函数中；
    
      - 如果这几种继承都不适用，又提出了**原型式继承(Object.create())**、**寄生式继承**和**寄生组合式继承**，
    
        - 原型式继承在函数内部(obejct(o))临时定义个构造函数，把o作为构造函数的原型对象，返回这个构造函数的实例；Object.create()就是对这种继承方式的规范化实现，这种也存在包含 引用类型值的属性会共享该值；
    
          ```js
          function object (o) {
            function F() {};
            F.prototype = o;
            return new F();
          }
          ```
    
          
    
        - 寄生式继承其实就是创建一个封装继承过程的函数,在函数内部对传入的对象进行增强，然后返回增加的对象，但这种也会存在于构造函数模式一样的问题，函数不能复用；
    
          ```js
          function createAnother (original) {
            const clone = object(original);
            // 对clone对象进行增加
            clone.ownMethod = () => {};
            return clone
          }
          ```
    
          
    
        - 寄生组合继承，寄生组合继承就是借用构造函数继承属性，原型链的混成形式继续方法，不必为了指定子类型的原型而调用超类型的构造函数，一般这种模式普遍被认为是理想的模式，
    
          ```js
          function inheritPrototype (SuperType, SubType) {
          	const prototype = object(SuperType.prototype);
            prototype.constructor = SubType
            SubType.prototype = prototype;
          }
          ```
    
          
    
      因为es中继承各种或多或少的问题，所以再现在开发中引入TS，辅助开发。extends用于扩展父类，mixin混合多种类组成新的类
    
    - 多态：针对某个对象的方法或属性，在实际运行时可能会有不同的实现，体现了可扩展性和多样性
  
- JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是**「加分」**，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。

- 为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？



### 如何理解 JS 异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

   - 因为js一开始是针对浏览器的脚本语言，需要用它来操作DOM，若js可以多线程进行，则容易造成在删除增加DOM时候出现问题，所以js是单线程的(代码从上到下依次执行)。但浏览器不是，为了提升性能，浏览器会先在调用找依次执行同步代码，对于异步代码会等异步任务完成后将异步回调处理函数加入等待执行的任务队列(先进先出);

  - 调用找实行先进后出原则，会保存代码执行期间所有执行上下文，排队的任务会依次push进调用找执行后清除;

  - 当有多个异步任务(即所谓的宏任务)时，后执行的异步代码比之前的异步代码先返回结果，这时，会让先得到返回结果的异步回调先进入任务队列；若这个异步任务执行后还有其他的后续任务处理(微任务)，会继续执行完当前所有的微任务才会执行下一个宏任务

  - 整体script代码相当于首个宏任务，宏任务有: setTimeOut、setInterval、requestAnimationFrame(浏览器)、I/O、用户交互事件(浏览器)等;

  - 微任务：process.nextTick(针对Node)、promise链式调用的函数(then catch finally)、MutationObserver；

  - 所以整体执行逻辑是，先执行同层级代码的宏任务，再执行当前宏任务下的微任务(包含微任务后又产生的微任务)，等同层级微任务执行完毕再执行下一个宏任务...这样就形成事件的循环

    

  - JS 异步编程

​     JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，  导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。

- EventLoop 事件环和消息队列

  **EventLoop** 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。

  **消息队列** 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。

  一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。

  当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。

  然后再取出一个宏任务执行。以此循环...

- 宏任务与微任务

  **宏任务**可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

  浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。

  宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等

​       **微任务**可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空任   务。 所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。

  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等



### 闭包、函数作用域和块、作用域链

- js执行会时会开辟一块内存作为执行环境，来规定执行期间允许获取到的所有信息，这些信息都被保存在变量对象中(EC),全局执行环境是最外层的执行环境
- 块级作用域：块级作用域由最近的一对包含花括号{}界定(这里涉及到**let var const**的区别)
- 执行上下文：代码在执行期间所能获取到的所有变量信息
- 函数作用域：函数在创建的时候就明确了作用域[[SCOPE]]，就是创建时所处的执行上下文
- 作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链，其作用是保证对当前执行环境有权访问的变量和函数进行有序访问，作用域链的前端，始终都是当前执行的代码所 在环境的变量对象，全局执行环境的变量对象始终都是作用域链中的最后一个对象
- 闭包： 闭包是一种机制，当前函数执行时创建的执行的上下文不会被销毁，闭包可以保护这个私有上下文中的变量不受其他上下文的变量影响，而且当前上下文创建的数据可以被当前上下文以外的变量引用

### var、let 、const

- var：声明的变量在函数作用域内，提升变量声明到函数作用域顶部，但值不会； 可用var重复申明同一个变量；var在全局作用域申明的变量在web环境中会成为window的属性(node环境没有BOM)
-  let: 声明的变量范围是块作用域；具有暂时性死区，不可进行变量提升；let不可重复声明同一个变量，但与var声明的变量一样可重复赋值；let在全局作用域申明的变量不能成为window的属性
- const: 基本与let一致，但不能给变量重新赋值，且声明变量的同时也要进行变量初始化；



### this的指向问题

  - 定义：this是当前函数执行的主体，即谁执行了函数，不等于执行上下文也不是当前作用域  
  - 在标准函数中this引用的是调用这个函数时的对象，(全局上下文中就是window，o.Foo(), Foo中的this就是o，匿名函数自调用一般是window | undefined)；回调函数的this一般也是window或undefined
  - 箭头函数中的 this 会保留定义该函数时的上下文；
  - 事件绑定：无论是哪一级绑定事件一般都是被操作元素
  - 构造函数调用(new)
    - **创建一个新对象**、
    - **新对象的[[ProtoType]] 赋值为构造函数的prototype属性(即新建的实例的属性方法是在原型对象上)**
    - **构造函数内部的 this 被赋值为这个新对象(this指向这个新对象)**
    - **执行构造函数内部代码(给新对象增加属性或方法)**
    - **构造函数有无返回(不返回或返回一个基本数据类型都相当于不返回)，**有且不为空的一个**对象**返回这个对象，否则就返回新建的新对象
      new Class(使用new 调用的是class的构造函数)
    - new Foo  (优先级19) 和 new Foo() (优先级20) 优先级不一样， new 操作符都会将函数重新执行

### 函数式编程、高阶函数、函数柯里化

- 函数式编程： 对数据映射关系的描述，方便代码的重用，函数可作为变量参数和返回值

  - 纯函数： 传入相同的值返回相同
  - 副作用：异步函数，返回值不一定相同

- 高阶函数：抽象代码，让代码更简洁、逻辑更清晰、能更注重业务逻辑

- 柯里化：让有多个参数的函数可以分多次传入参数再调用，即fn(n1,n2,n3,n4) => fn1(n1)(n2)(n3))(n4) 或者fn1(n1,n2)(n3,n4)

  ```js
  // 参数是个函数，返回的也是个函数
  // 返回的函数可以分多次传入参数
  // 在返回的函数内部，当接受的参数个数与最原始参数值相同(或大于)时要执行这个函数，参数小于原本的参数个数时返回一个函数
  function curry (fn) {
    return function curried(...args) {
      if (args.length < fn.length) {
        return () => arguments.callee(...args, ...arguments)
      }
      return fn(...args)
    }
  }
  ```

  







1. 节流防抖实现？区别作用？

     

2. require 和import 的区别？
    CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用。
    CommonJs模块是运行时加载，ES6模块是编译时输出接口。

3. 排序算法(至少三种)*

4. 函数柯里化

5. 数组去重

7. Mixins 和 高阶函数 、Hook

8. sum(1) sum(1)(2)(3)(4) sum(1, 2, 3, 4);

9. node 的模块

10. 模块知识、JS怎么实现继承？

11. ***宏任务、微任务、事件循环、任务队列、调用栈(Call Stack 、Execution Context)？

     事件循环是执行栈和消息队列的桥梁

     

12. 进程与线程？

     进程： 相当于打开一个应用程序(打开浏览器页面浏览器是多进程，多个页面互不干扰)

     线程： 相当于应用程序中具体做事情的人，

     throw error后，后续代码不会执行，但是前面添加的异步代码会执行，死循环主线程会一直占用，所以异步的回调都不会放入主线程执行

13. 打开一个浏览器会有哪些进程

     DOM事件监听

     网络请求处理线程

     定时器

     GUI界面渲染

     js引擎执行线程，主线程

14. 对Symbol的理解？(是什么，属性方法，用途)
          https://juejin.cn/post/6925619440843227143
         每个从Symbol()返回的symbol值都是唯一的，一个symbol值能作为对象属性的标识符 —— 这是该数据类型仅有的目的

15. super方法的理解？super关键字用于访问和调用一个对象的父对象上的函数,
         super 关键字使用的注意几个问题：
       只能在派生类的构造函数实例方法和静态方法中使用...
       在派生类中的构造函数中super()要在this使用之前(原因)
       如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回 一个对象
          https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super

16. weakMap 和 Map的区别， Set和weakSet？
         集合 与 字典 的区别：
         共同点：集合、字典 可以储存不重复的值
         不同点：集合 是以 {value, value}的形式储存元素，字典 是以 {key => value} 的形式储存
         WeakMap 对象是一组键值对的集合，其中的键是弱引用对象(垃圾回收机制，不可枚举)，而值可以是任意。
         WeakSet 对象允许你将弱引用对象储存在一个集合中
         Set
       成员唯一、无序且不重复
       [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
       可以遍历，方法有：add、delete、has
         WeakSet
       成员都是对象
       成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
       不能遍历，方法有add、delete、has
         Map
       本质上是键值对的集合，类似集合
       可以遍历，方法很多可以跟各种数据格式转换
         WeakMap
       只接受对象作为键名（null除外），不接受其他类型的值作为键名
       键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
       不能遍历，方法有get、set、has、delete
         https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/6

17. 数据结构?
          基本数据类型： string number(NaN == NaN false) symbol boolean null(null 值表示一个空对象指针) undefined bigint
          引用类型： object array set map

20. 理解promise

     promise 的executor函数报错时，此时promise实例的状态会是rejected，此时值是报错的原因

      resolve()后续的代码也会执行

     then中的回调函数执行不报错范湖都是fulfilled的promise，如果返回的是promise，就是这个返回promise的状态

21. Async 

     async函数执行返回的是一个promise，如果函数体内没有报错，返回的就是fulfilled的promise值为函数返回的值，没有就是undefined

     - await一般配合async使用，后面放的是promsie的实例，如果不是则会转为promise的实例
     - await foo() ，此时foo函数会被立即调用，且foo的返回值可以被处理成promise值，await 后面的代码相当于then

22. 函数 : 函数所有参数是按值传入的，原始值传入函数不影响外部值，对象按值传入函数(把对象作为参数传       递，那么传递的值就是这个对象的引用)，但以引用的方式来访问这个传入的对象（函数的参数就是局部变量）
       默认参数：传入undefined相当于不传会使用默认参数,后定义默认值的参数可以引用先定义的参数,前面定义的参数不能引用后面定义
       函数内部存在的对象：
       arguments : (callee指向arguments所在函数的指针)

    
    
26. Date RegExp 等创建的实例都有 toLocalString() toString() valueof() 等方法；
        原始值包装类型：
        Boolean
        Number
        String =>（slice()、substr(子字符串截取的开始位置index， 截取子字符串的长度)和 substring()）

27. yield 生成器， Generator 函数赋值时不会执行函数内部内容，第一次调用的next内不需要参数，输入的参数也会忽略，随后输入的next参数是执行下一个yield相关代买需要的输入或输出,每一个yield执行完就停止，等待下一次next的调用再执行yield，执行next()后返回结果中的res.value是yield 表达式或return的返回；
        自定义生成器自动执行函数
        function runGen (gen, arr = []) {
          let res;
          if (arr.length > 0) {
        res = gen.next(arr[arr.length - 1].value);
          } else {
        res = gen.next();
          }
          arr.push(res);
          if (!res.done) {
        return runGen(gen, arr);
          } else {
        return arr;
          }
        }

28. 实现默认迭代器(生成器生成默认迭代器)
         class Foo {
        constructor() {
          this.values = [1, 2, 3];
        }
        *[[Symbol.iterator]]() {
          yield*  this.values;
        }
         }

29. 有哪些设计模式？工厂模式、迭代模式、原型模式、代理模式(用途？涉及到Reflect api，四版第九章)

